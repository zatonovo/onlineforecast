---
title: "DRAFT Building electricity load forecasting"
author: "Peder Bacher"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Building heat load forecasting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: literature.bib
---

```{r setup, include = FALSE, purl = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">",
  cache = FALSE, # Somehow it doesn't work
  fig.height=6.5, 
  fig.width=13, 
  out.width="685px"
)
options(digits=3)
```

## Intro
This vignette presents an example of using the onlineforecasting
package for fitting a model and calculating forecasts as carried out
by @Bacher2012.

## Data
Data for the forecasting examples is taken from a data set collected
in SÃ¸nderborg, Denmark. It comprises heat load measurements for
sixteen houses, together with local climate observations and weather
forecasts (NWPs). The houses are generally built in the sixties and
seventies, with a floor plan in the range of 85 to 170 $\mr{m^2}$, and
constructed in bricks. For each house only the total heat load, including both space heating and hot tab water heating, is available. The climate observations are measured at the local district heating plant within 10 kilometers from the houses. The NWPs are from the HIRLAM-S05 model and provided by the Danish Meteorological Institute. All times are in UTC and the time stamp for average values are set to the end of the time interval.

Load the package:
```{r}
##library(devtools)
##load_all(as.package("../../onlineforecast"), export_all=FALSE)
## Remember
##install.packages("onlineforecast_0.1.0.tar.gz")
library(onlineforecast)
```

The "Dbuilding" data is included in the package. Its a data.list (see the vignette onlineforecasting.pdf):
```{r}
Dbuilding <- readRDS("Dbuilding.Rda")
```

Keep it in D and see the content:
```{r}
D <- Dbuilding
names(D)
```

The time:
```{r}
head(D$t)
```

The observed heat load (in kW) of the different houses are kept in a data.frame:
```{r}
head(D$Electricityload$house1)
```

The Numerical Weather Predictions (NWPs) of ambient temperature steps 0 to 8 hours ahead are:
```{r}
head(D$Ta[ ,1:9])
```
So at "2008-12-01 01:00:00 GMT" the latest available forecasts is the first row of Ta.

Choose the heat load of House 9 for the example, just keep it as a vector y:
```{r}
D$y <- D$Electricityload$house3
```

A time series plot, see "?plot_ts.data.list" (Note how the forecasts Ta are lagged to be synced with observations (i.e. then also with each other))
```{r}
plot_ts(D, c("^y","Ta"), kseq=c(1,12))
```

A shorter period:
```{r}
plot_ts(D, c("^y","Ta"), "2010-12-15", "2010-12-25", kseq=c(1,12))

plot_ts(D, c("^y","Ta"), "2009-12-15", "2011-12-25", kseq=c(1,12))


tmp <- subset(D, c("2010-12-15", "2011-12-15"), kseq=1:6, pattern=c("^y|^Ta"))
pairs(tmp)
```

Set the index of the training period and which period to evaluate (when fitting the points with scoreperiod==false are not included in the score evaluation)
```{r}
Dtrain <- subset(D, c("2010-06-01", "2011-06-01"))
Dtrain$scoreperiod <- in_range("2010-06-10", Dtrain$t)
```

Define a model
```{r}
model <- forecastmodel$new()
model$output = "y"
model$add_inputs(Ta = "lp(Ta, a1=0.9)", 
                 I = "lp(I, a1=0.7)", 
                 mu_tday = "fs(tday/24, nharmonics=10)",
                 mu = "ones()")
model$add_regprm("rls_prm(lambda=0.9)")
```

Define the parameters to be optimized offline (their lower, init and upper bound)
```{r}
model$add_prmbounds(Ta__a1 = c(0.8, 0.9, 0.9999),
                    I__a1 =  c(0.4, 0.8, 0.9999),
                    lambda = c(0.9, 0.99, 0.9999))
```

Tune the parameters: first set the horizons to run and the 
```{r, results="hide"}
model$kseq <- c(1,18)
model$prm <- rls_optim(model, Dtrain, control=list(maxit=2), cachedir = "cache-building-heat-load-forecasting")$par
```

Now fit with the optimized parameters on the entire period
```{r}
model$kseq <- 1:36
val <- rls_fit(model$prm, model, D, returnanalysis = TRUE)
```

Plot the forecasts (Yhat adheres to the forecast matrix format and in plot_ts the forecasts are lagged k steps to sync with the observations)
```{r, fig.height=4}
D$Yhat <- val$Yhat
plot_ts(D, c("^y|^Y"), "2010-06-01", "2011-06-01", kseq = c(1,18))
plot_ts(D, c("^y|^Y"), "2010-07-01", "2010-07-15", kseq = c(1,18))
plot_ts(D, c("^y|^Y"), "2010-08-01", "2010-08-05", kseq = c(1,18))
plot_ts(D, c("^y|^Y"), "2010-12-15", "2010-12-30", kseq = c(1,18))
```

Plot a forecast for a particular time point
```{r, fig.height=4}
i <- 5000
iseq <- i+model$kseq
plot(D$t[iseq], D$y[iseq], type = "b", xlab = "t", ylab = "y")
lines(D$t[iseq], D$Yhat[i, ], type = "b", col = 2)
legend("topright", c("Observations",pst("Predictions (",min(model$kseq)," to ",max(model$kseq)," steps ahead)")), lty = 1, col = 1:2)
```

### Recursive update and prediction
First fit on a period
```{r}
iseq <- which(in_range("2010-12-15",D$t,"2011-01-01"))
Dfit <- subset(D, iseq)
rls_fit(model$prm, model, Dfit)
```

Now the fits are saved in the model object (its an R6 object, hence passed by reference to the functions and can be changed inside the functions). A list of fits with an entry for each horizon is in Lfits, see the two first
```{r}
str(model$Lfits[1:2])
```

Now new data arrives, take the point right after the fit period
```{r}
(i <- iseq[length(iseq)] + 1)
Dnew <- subset(D, i)
```

First we need to transform the new data (This must only be done once for each new data, since some transform functions, e.g. lp(), actually keep states, see the detailed vignette onlineforecasting.pdf)
```{r}
Dnew_transformed <- model$transform_data(Dnew)
```

Then we can update the parameters using the transformed data
```{r}
rls_update(model, Dnew_transformed, Dnew[[model$output]])
```

Calculate predictions using the new data and the updated fits (rls coefficient estimates in model$Lfits[[k]]$theta)
```{r}
yhat <- rls_predict(model, Dnew_transformed)
```

Plot to see that it fits the observations
```{r}
iseq <- i+model$kseq
plot(D$t[iseq], D$y[iseq], type = "b", xlab = "t", ylab = "y")
lines(D$t[iseq], yhat, type = "b", col = 2)
legend("topright", c("observations",pst("predictions (",min(model$kseq)," to ",max(model$kseq)," steps ahead)")), lty = 1, col = 1:2)
```

Run this for a longer period to verify that the same forecasts are obtained (in one go vs. iteratively)

First in one go
```{r}
val <- rls_fit(model$prm, model, D, returnanalysis = TRUE)
D$Yhat1 <- val$Yhat
```

and then iteratively
```{r}
itrain <- which(in_range("2010-12-15",D$t,"2011-01-01"))
itest <- which(in_range("2011-01-01",D$t,"2011-01-04"))
rls_fit(model$prm, model, subset(D, itrain))

D$Yhat2 <- data.frame(matrix(NA, nrow(D$Yhat1), ncol(D$Yhat1)))
names(D$Yhat2) <- names(D$Yhat1)
for(i in itest){
    print(i)
    Dnew <- subset(D, i)
    Dnewtr <- model$transform_data(Dnew)
    rls_update(model, Dnewtr, Dnew[[model$output]])
    D$Yhat2[i, ] <- as.numeric(rls_predict(model, Dnewtr))
}
```

Compare to see the difference between the one step forecasts
```{r}
D$Yhat1$k1[itest] - D$Yhat2$k1[itest]
plot(D$Yhat1$k1[itest], type="b")
lines(D$Yhat2$k1[itest], type="b", col=2)
```

## Literature
